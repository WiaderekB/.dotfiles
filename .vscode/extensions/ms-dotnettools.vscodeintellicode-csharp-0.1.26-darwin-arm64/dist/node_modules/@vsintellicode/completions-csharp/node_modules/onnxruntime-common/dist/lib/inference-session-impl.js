import{resolveBackend}from"./backend-impl";import{Tensor}from"./tensor";export class InferenceSession{constructor(e){this.handler=e}async run(e,t,r){const n={};let o={};if("object"!=typeof e||null===e||e instanceof Tensor||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==i.indexOf(r)){const o=t[r];(null===o||o instanceof Tensor)&&(e=!0,s=!1,n[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(s)for(const e of this.outputNames)n[e]=null;const i=await this.handler.run(e,n,o),a={};for(const e in i)Object.hasOwnProperty.call(i,e)&&(a[e]=new Tensor(i[e].type,i[e].data,i[e].dims));return a}static async create(e,t,r,n){let o,s={};if("string"==typeof e){if(o=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(o=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const i=e;let a=0,f=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(a=t,!Number.isSafeInteger(a))throw new RangeError("'byteOffset' must be an integer.");if(a<0||a>=i.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${i.byteLength}).`);if(f=e.byteLength-a,"number"==typeof r){if(f=r,!Number.isSafeInteger(f))throw new RangeError("'byteLength' must be an integer.");if(f<=0||a+f>i.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${i.byteLength-a}].`);if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else if(void 0!==r)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");o=new Uint8Array(i,a,f)}}const i=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),a=await resolveBackend(i),f=await a.createSessionHandler(o,s);return new InferenceSession(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}