/*! For license information please see ort-common.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ort=t():e.ort=t()}(self,(()=>(()=>{"use strict";var e={"./lib/backend-impl.ts":(e,t,r)=>{r.r(t),r.d(t,{registerBackend:()=>o,resolveBackend:()=>a});const n={},i=[],o=(e,t,r)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const o=n[e];if(void 0===o)n[e]={backend:t,priority:r};else{if(o.priority>r)return;if(o.priority===r&&o.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){const t=i.indexOf(e);-1!==t&&i.splice(t,1);for(let t=0;t<i.length;t++)if(n[i[t]].priority<=r)return void i.splice(t,0,e);i.push(e)}}},a=async e=>{const t=0===e.length?i:e,r=[];for(const e of t){const t=n[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(i){n||r.push({name:e,err:i}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)}},"./lib/backend.ts":(e,t,r)=>{r.r(t),r.d(t,{registerBackend:()=>n.registerBackend});var n=r("./lib/backend-impl.ts")},"./lib/env-impl.ts":(e,t,r)=>{r.r(t),r.d(t,{EnvImpl:()=>n});class n{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}}},"./lib/env.ts":(e,t,r)=>{r.r(t),r.d(t,{env:()=>n});const n=new(r("./lib/env-impl.ts").EnvImpl)},"./lib/inference-session-impl.ts":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>o});var n=r("./lib/backend-impl.ts"),i=r("./lib/tensor.ts");class o{constructor(e){this.handler=e}async run(e,t,r){const n={};let o={};if("object"!=typeof e||null===e||e instanceof i.Tensor||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof i.Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const s=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==s.indexOf(r)){const o=t[r];(null===o||o instanceof i.Tensor)&&(e=!0,a=!1,n[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(const e of this.outputNames)n[e]=null;const s=await this.handler.run(e,n,o),d={};for(const e in s)Object.hasOwnProperty.call(s,e)&&(d[e]=new i.Tensor(s[e].type,s[e].data,s[e].dims));return d}static async create(e,t,r,i){let a,s={};if("string"==typeof e){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const n=e;let o=0,d=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=n.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${n.byteLength}).`);if(d=e.byteLength-o,"number"==typeof r){if(d=r,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||o+d>n.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${n.byteLength-o}].`);if("object"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError("'options' must be an object.")}else if(void 0!==r)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");a=new Uint8Array(n,o,d)}}const d=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),f=await(0,n.resolveBackend)(d),h=await f.createSessionHandler(a,s);return new o(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}},"./lib/inference-session.ts":(e,t,r)=>{r.r(t),r.d(t,{InferenceSession:()=>n});const n=r("./lib/inference-session-impl.ts").InferenceSession},"./lib/onnx-value.ts":(e,t,r)=>{r.r(t)},"./lib/tensor-impl.ts":(e,t,r)=>{r.r(t),r.d(t,{Tensor:()=>s});const n="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,i="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,o=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),a=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);n&&(o.set("int64",BigInt64Array),a.set(BigInt64Array,"int64")),i&&(o.set("uint64",BigUint64Array),a.set(BigUint64Array,"uint64"));class s{constructor(e,t,r){let n,i,s;if("string"==typeof e)if(n=e,s=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{const r=o.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))i=r.from(t);else{if(!(t instanceof r))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);i=t}}else if(s=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)n="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n="bool",i=Uint8Array.from(e)}}else{const t=a.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,i=e}if(void 0===s)s=[i.length];else if(!Array.isArray(s))throw new TypeError("A tensor's dims must be a number array");const d=(e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t})(s);if(d!==i.length)throw new Error(`Tensor's size(${d}) does not match data length(${i.length}).`);this.dims=s,this.type=n,this.data=i,this.size=d}static bufferToTensor(e,t){if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");const{height:r,width:n}=t,i=t.norm;let o,a;o=void 0===i||void 0===i.mean?255:i.mean,a=void 0===i||void 0===i.bias?0:i.bias;const d=void 0!==t.bitmapFormat?t.bitmapFormat:"RGBA",f=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",h=r*n,l="RGBA"===f?new Float32Array(4*h):new Float32Array(3*h);let m=4,c=0,g=1,u=2,p=3,w=0,y=h,b=2*h,v=-1;"RGB"===d&&(m=3,c=0,g=1,u=2,p=-1),"RGBA"===f?v=3*h:"RBG"===f?(w=0,b=h,y=2*h):"BGR"===f&&(b=0,y=h,w=2*h);for(let t=0;t<h;t++,c+=m,u+=m,g+=m,p+=m)l[w++]=(e[c]+a)/o,l[y++]=(e[g]+a)/o,l[b++]=(e[u]+a)/o,-1!==v&&-1!==p&&(l[v++]=(e[p]+a)/o);return new s("float32",l,"RGBA"===f?[1,4,r,n]:[1,3,r,n])}static async fromImage(e,t){const r="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,n="undefined"!=typeof ImageData&&e instanceof ImageData,i="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,o="undefined"!=typeof String&&(e instanceof String||"string"==typeof e);let a,d={};if(r){const r=document.createElement("canvas"),n=r.getContext("2d");if(null==n)throw new Error("Can not access image data");{let i=e.naturalHeight,o=e.naturalWidth;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(i=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(d=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(d.tensorFormat="RGBA",void 0!==t.height&&t.height!==i)throw new Error("Image input config height doesn't match HTMLImageElement height");if(d.height=i,void 0!==t.width&&t.width!==o)throw new Error("Image input config width doesn't match HTMLImageElement width");d.width=o}else d.tensorFormat="RGBA",d.height=i,d.width=o;r.width=o,r.height=i,n.drawImage(e,0,0,o,i),a=n.getImageData(0,0,o,i).data}}else{if(!n){if(i){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==t.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const r=document.createElement("canvas").getContext("2d");if(null!=r){const n=e.height,i=e.width;if(r.drawImage(e,0,0,i,n),a=r.getImageData(0,0,i,n).data,void 0!==t){if(void 0!==t.height&&t.height!==n)throw new Error("Image input config height doesn't match ImageBitmap height");if(d.height=n,void 0!==t.width&&t.width!==i)throw new Error("Image input config width doesn't match ImageBitmap width");d.width=i}else d.height=n,d.width=i;return s.bufferToTensor(a,d)}throw new Error("Can not access image data")}if(o)return new Promise(((r,n)=>{const i=document.createElement("canvas"),o=i.getContext("2d");if(!e||!o)return n();const a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{i.width=a.width,i.height=a.height,o.drawImage(a,0,0,i.width,i.height);const e=o.getImageData(0,0,i.width,i.height);if(void 0!==t){if(void 0!==t.height&&t.height!==i.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(d.height=i.height,void 0!==t.width&&t.width!==i.width)throw new Error("Image input config width doesn't match ImageBitmap width");d.width=i.width}else d.height=i.height,d.width=i.width;r(s.bufferToTensor(e.data,d))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const r="RGBA";let n,i;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,i=t.resizedWidth):(n=e.height,i=e.width),void 0!==t){if(d=t,void 0!==t.bitmapFormat&&t.bitmapFormat!==r)throw new Error("Image input config format must be RGBA for ImageData");d.bitmapFormat="RGBA"}else d.bitmapFormat="RGBA";if(d.height=n,d.width=i,void 0!==t){const t=document.createElement("canvas");t.width=i,t.height=n;const r=t.getContext("2d");if(null==r)throw new Error("Can not access image data");r.putImageData(e,0,0),a=r.getImageData(0,0,i,n).data}else a=e.data}}if(void 0!==a)return s.bufferToTensor(a,d);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,r;const n=document.createElement("canvas").getContext("2d");let i;if(null==n)throw new Error("Can not access image data");{const o=this.dims[3],a=this.dims[2],s=this.dims[1],d=void 0!==e&&void 0!==e.format?e.format:"RGB",f=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,h=void 0!==e&&void 0!==(null===(r=e.norm)||void 0===r?void 0:r.bias)?e.norm.bias:0,l=a*o;if(void 0!==e){if(void 0!==e.height&&e.height!==a)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==o)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===s&&"RGBA"!==e.format||3===s&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const m=4;let c=0,g=1,u=2,p=3,w=0,y=l,b=2*l,v=-1;"RGBA"===d?(w=0,y=l,b=2*l,v=3*l):"RGB"===d?(w=0,y=l,b=2*l):"RBG"===d&&(w=0,b=l,y=2*l),i=n.createImageData(o,a);for(let e=0;e<a*o;c+=m,g+=m,u+=m,p+=m,e++)i.data[c]=(this.data[w++]-h)*f,i.data[g]=(this.data[y++]-h)*f,i.data[u]=(this.data[b++]-h)*f,i.data[p]=-1===v?255:(this.data[v++]-h)*f}return i}reshape(e){return new s(this.type,this.data,e)}}},"./lib/tensor.ts":(e,t,r)=>{r.r(t),r.d(t,{Tensor:()=>n});const n=r("./lib/tensor-impl.ts").Tensor}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.r(n),r.d(n,{InferenceSession:()=>i.InferenceSession,Tensor:()=>o.Tensor,env:()=>t.env,registerBackend:()=>e.registerBackend});var e=r("./lib/backend.ts"),t=r("./lib/env.ts"),i=r("./lib/inference-session.ts"),o=r("./lib/tensor.ts");r("./lib/onnx-value.ts")})(),n})()));