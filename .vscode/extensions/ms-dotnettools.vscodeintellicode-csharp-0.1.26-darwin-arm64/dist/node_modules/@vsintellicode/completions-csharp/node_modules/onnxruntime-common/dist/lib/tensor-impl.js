const isBigInt64ArrayAvailable="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,isBigUint64ArrayAvailable="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64")),isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64"));const calculateSize=t=>{let e=1;for(let r=0;r<t.length;r++){const i=t[r];if("number"!=typeof i||!Number.isSafeInteger(i))throw new TypeError(`dims[${r}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${i}`);e*=i}return e};export class Tensor{constructor(t,e,r){let i,o,a;if("string"==typeof t)if(i=t,a=r,"string"===t){if(!Array.isArray(e))throw new TypeError("A string tensor's data must be a string array.");o=e}else{const r=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(t);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(e))o=r.from(e);else{if(!(e instanceof r))throw new TypeError(`A ${i} tensor's data must be type of ${r}`);o=e}}else if(a=e,Array.isArray(t)){if(0===t.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const e=typeof t[0];if("string"===e)i="string",o=t;else{if("boolean"!==e)throw new TypeError(`Invalid element type of data array: ${e}.`);i="bool",o=Uint8Array.from(t)}}else{const e=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(t.constructor);if(void 0===e)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);i=e,o=t}if(void 0===a)a=[o.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");const n=calculateSize(a);if(n!==o.length)throw new Error(`Tensor's size(${n}) does not match data length(${o.length}).`);this.dims=a,this.type=i,this.data=o,this.size=n}static bufferToTensor(t,e){if(void 0===t)throw new Error("Image buffer must be defined");if(void 0===e.height||void 0===e.width)throw new Error("Image height and width must be defined");const{height:r,width:i}=e,o=e.norm;let a,n;a=void 0===o||void 0===o.mean?255:o.mean,n=void 0===o||void 0===o.bias?0:o.bias;const d=void 0!==e.bitmapFormat?e.bitmapFormat:"RGBA",h=void 0!==e.tensorFormat&&void 0!==e.tensorFormat?e.tensorFormat:"RGB",s=r*i,m="RGBA"===h?new Float32Array(4*s):new Float32Array(3*s);let g=4,f=0,w=1,c=2,l=3,A=0,u=s,y=2*s,p=-1;"RGB"===d&&(g=3,f=0,w=1,c=2,l=-1),"RGBA"===h?p=3*s:"RBG"===h?(A=0,y=s,u=2*s):"BGR"===h&&(y=0,u=s,A=2*s);for(let e=0;e<s;e++,f+=g,c+=g,w+=g,l+=g)m[A++]=(t[f]+n)/a,m[u++]=(t[w]+n)/a,m[y++]=(t[c]+n)/a,-1!==p&&-1!==l&&(m[p++]=(t[l]+n)/a);return new Tensor("float32",m,"RGBA"===h?[1,4,r,i]:[1,3,r,i])}static async fromImage(t,e){const r="undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement,i="undefined"!=typeof ImageData&&t instanceof ImageData,o="undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap,a="undefined"!=typeof String&&(t instanceof String||"string"==typeof t);let n,d={};if(r){const r=document.createElement("canvas"),i=r.getContext("2d");if(null==i)throw new Error("Can not access image data");{let o=t.naturalHeight,a=t.naturalWidth;if(void 0!==e&&void 0!==e.resizedHeight&&void 0!==e.resizedWidth&&(o=e.resizedHeight,a=e.resizedWidth),void 0!==e){if(d=e,void 0!==e.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(d.tensorFormat="RGBA",void 0!==e.height&&e.height!==o)throw new Error("Image input config height doesn't match HTMLImageElement height");if(d.height=o,void 0!==e.width&&e.width!==a)throw new Error("Image input config width doesn't match HTMLImageElement width");d.width=a}else d.tensorFormat="RGBA",d.height=o,d.width=a;r.width=a,r.height=o,i.drawImage(t,0,0,a,o),n=i.getImageData(0,0,a,o).data}}else{if(!i){if(o){if(void 0===e)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==e.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const r=document.createElement("canvas").getContext("2d");if(null!=r){const i=t.height,o=t.width;if(r.drawImage(t,0,0,o,i),n=r.getImageData(0,0,o,i).data,void 0!==e){if(void 0!==e.height&&e.height!==i)throw new Error("Image input config height doesn't match ImageBitmap height");if(d.height=i,void 0!==e.width&&e.width!==o)throw new Error("Image input config width doesn't match ImageBitmap width");d.width=o}else d.height=i,d.width=o;return Tensor.bufferToTensor(n,d)}throw new Error("Can not access image data")}if(a)return new Promise(((r,i)=>{const o=document.createElement("canvas"),a=o.getContext("2d");if(!t||!a)return i();const n=new Image;n.crossOrigin="Anonymous",n.src=t,n.onload=()=>{o.width=n.width,o.height=n.height,a.drawImage(n,0,0,o.width,o.height);const t=a.getImageData(0,0,o.width,o.height);if(void 0!==e){if(void 0!==e.height&&e.height!==o.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(d.height=o.height,void 0!==e.width&&e.width!==o.width)throw new Error("Image input config width doesn't match ImageBitmap width");d.width=o.width}else d.height=o.height,d.width=o.width;r(Tensor.bufferToTensor(t.data,d))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const r="RGBA";let i,o;if(void 0!==e&&void 0!==e.resizedWidth&&void 0!==e.resizedHeight?(i=e.resizedHeight,o=e.resizedWidth):(i=t.height,o=t.width),void 0!==e){if(d=e,void 0!==e.bitmapFormat&&e.bitmapFormat!==r)throw new Error("Image input config format must be RGBA for ImageData");d.bitmapFormat="RGBA"}else d.bitmapFormat="RGBA";if(d.height=i,d.width=o,void 0!==e){const e=document.createElement("canvas");e.width=o,e.height=i;const r=e.getContext("2d");if(null==r)throw new Error("Can not access image data");r.putImageData(t,0,0),n=r.getImageData(0,0,o,i).data}else n=t.data}}if(void 0!==n)return Tensor.bufferToTensor(n,d);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(t){var e,r;const i=document.createElement("canvas").getContext("2d");let o;if(null==i)throw new Error("Can not access image data");{const a=this.dims[3],n=this.dims[2],d=this.dims[1],h=void 0!==t&&void 0!==t.format?t.format:"RGB",s=void 0!==t&&void 0!==(null===(e=t.norm)||void 0===e?void 0:e.mean)?t.norm.mean:255,m=void 0!==t&&void 0!==(null===(r=t.norm)||void 0===r?void 0:r.bias)?t.norm.bias:0,g=n*a;if(void 0!==t){if(void 0!==t.height&&t.height!==n)throw new Error("Image output config height doesn't match tensor height");if(void 0!==t.width&&t.width!==a)throw new Error("Image output config width doesn't match tensor width");if(void 0!==t.format&&4===d&&"RGBA"!==t.format||3===d&&"RGB"!==t.format&&"BGR"!==t.format)throw new Error("Tensor format doesn't match input tensor dims")}const f=4;let w=0,c=1,l=2,A=3,u=0,y=g,p=2*g,E=-1;"RGBA"===h?(u=0,y=g,p=2*g,E=3*g):"RGB"===h?(u=0,y=g,p=2*g):"RBG"===h&&(u=0,p=g,y=2*g),o=i.createImageData(a,n);for(let t=0;t<n*a;w+=f,c+=f,l+=f,A+=f,t++)o.data[w]=(this.data[u++]-m)*s,o.data[c]=(this.data[y++]-m)*s,o.data[l]=(this.data[p++]-m)*s,o.data[A]=-1===E?255:(this.data[E++]-m)*s}return o}reshape(t){return new Tensor(this.type,this.data,t)}}